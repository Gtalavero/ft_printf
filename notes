valgrind --leak-check=full --show-leak-kinds=definite --track-origins=yes ./a.out

Revisar petadas de los "p", sobre todo 442 y 447 fallan muy de vez en Cuando (parece que ya van)

440
445
447

Test 336 (x_basic_pos) : FAILED.
    First line of code: {return test("this %x number", 17);}
    Timed out

mallocs:
¿protegidos?


*printf("%.0d", -8472); caso del test #208


*Mirar al llamar a ceroflag en final_str los malloc
*Leaks y demás

ESTRUCTURA
%[FLAG][WIDTH][.PRECISION][LENGHT][TYPE]

FLAGS: -0.*
	-	Alinear a la izquierda. Si por defecto es "  hola" será "hola  "
	0	Se rellenará con ceros a la izq hasta el valor del nº.
		Para conversiones: d, i, u, x, X, y de BONUS: e, f, g(BONUS).
		Si se usa '-', el '0' se ignora.
		Si hay precisión en una conv decimal (d, i, u, x, X) también se ignora el '0'.
	.	(Ver precisión)
	*	(Ver width)

WIDTH - Tamaño mínimo del campo donde se imprimirá el valor
	Es opcional
	Si el valor a convertir tiene menos longitud que el width, será "padded" con espacios a la izq,
		o a la derecha si existe el flag '-'
	*	Indicaremos que el tamaño se especificará en el siguiente argumento. Si ponemos un número
			después	del '*' indicaremos en qué argumento especificaremos el width
	NUNCA un width pequeño o inexistente truncará un field.

PRECISION d, i, u, x, X, s
	Es opcional
	Número mínimo de dígitos para: (d, i, u, x y X).
	Número de caracteres a imprimir para cadenas de texto (s)
	*	Indicaremos que la precision se especificará en el siguiente argumento. Si ponemos un número
			después	del '*' indicaremos en qué argumento especificaremos la precisión
	Si tan solo ponemos '.' sin un número, la precisión = 0
	Si es negativa se interpretará como si se hubiera omitido
	Primará sobre el width
	Si existe, se omitirá el flag '0'


LENGHT - l ll h hh
	Solo para el BONUS

TIPOS: cspdiuxX%
	c		Imprime el carácter ASCII correspondiente. Imprime char
	s		Cadena de caracteres (terminada en '\0'). Imprime string
	p		Dirección de memoria (puntero) en dígitos hexadecimales
	d, i	Conversión decimal con signo de un entero. Imprime int
	u		Conversión decimal sin signo de un entero. Imprime int
	x, X	Conversión hexadecimal sin signo. Imprime int. La minúscula imprime en minúscula y la
			mayúscula en mayúscula.

FLAGS BONUS: l ll h hh
TIPOS BONUS: nfge





ORDEN
1. Creamos una estructura en el .h donde incluiremos las características de la string (lenght, flags, etc.)
2. Recorreremos el format:
Cuando nos encontremos un %, llamaremos a una función que:
	Conseguirá el width y la precisión y lo añadirá a la estructura

	comprobaremos si es un flag (0 o -) y lo asignaremos a la variable de la estructura.
Si el siguiente no es un especificador de conversión, comprobaremos su width y lenght



PENDIENTE:
Liberar la estructura


DUDAS
¿Impresión simple? printf("hola")

¿Carácteres de escape? \\ \" \' \%

¿Parámetro orden "%3$d"?






